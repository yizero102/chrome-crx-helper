// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: java/src/main/proto/crx3.proto

package crx_file;

public final class Crx3 {
  private Crx3() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface CrxFileHeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.CrxFileHeader)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    java.util.List<crx_file.Crx3.AsymmetricKeyProof> 
        getSha256WithRsaList();
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    crx_file.Crx3.AsymmetricKeyProof getSha256WithRsa(int index);
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    int getSha256WithRsaCount();

    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    java.util.List<crx_file.Crx3.AsymmetricKeyProof> 
        getSha256WithEcdsaList();
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    crx_file.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index);
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    int getSha256WithEcdsaCount();

    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     * @return Whether the verifiedContents field is set.
     */
    boolean hasVerifiedContents();
    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     * @return The verifiedContents.
     */
    com.google.protobuf.ByteString getVerifiedContents();

    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return Whether the signedHeaderData field is set.
     */
    boolean hasSignedHeaderData();
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return The signedHeaderData.
     */
    com.google.protobuf.ByteString getSignedHeaderData();
  }
  /**
   * Protobuf type {@code crx_file.CrxFileHeader}
   */
  public  static final class CrxFileHeader extends
      com.google.protobuf.GeneratedMessageLite<
          CrxFileHeader, CrxFileHeader.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.CrxFileHeader)
      CrxFileHeaderOrBuilder {
    private CrxFileHeader() {
      sha256WithRsa_ = emptyProtobufList();
      sha256WithEcdsa_ = emptyProtobufList();
      verifiedContents_ = com.google.protobuf.ByteString.EMPTY;
      signedHeaderData_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int SHA256_WITH_RSA_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.ProtobufList<crx_file.Crx3.AsymmetricKeyProof> sha256WithRsa_;
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public java.util.List<crx_file.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public java.util.List<? extends crx_file.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithRsaOrBuilderList() {
      return sha256WithRsa_;
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public int getSha256WithRsaCount() {
      return sha256WithRsa_.size();
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    @java.lang.Override
    public crx_file.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
      return sha256WithRsa_.get(index);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    public crx_file.Crx3.AsymmetricKeyProofOrBuilder getSha256WithRsaOrBuilder(
        int index) {
      return sha256WithRsa_.get(index);
    }
    private void ensureSha256WithRsaIsMutable() {
      com.google.protobuf.Internal.ProtobufList<crx_file.Crx3.AsymmetricKeyProof> tmp = sha256WithRsa_;
      if (!tmp.isModifiable()) {
        sha256WithRsa_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void setSha256WithRsa(
        int index, crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithRsaIsMutable();
      sha256WithRsa_.set(index, value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addSha256WithRsa(
        int index, crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithRsaIsMutable();
      sha256WithRsa_.add(index, value);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void addAllSha256WithRsa(
        java.lang.Iterable<? extends crx_file.Crx3.AsymmetricKeyProof> values) {
      ensureSha256WithRsaIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sha256WithRsa_);
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void clearSha256WithRsa() {
      sha256WithRsa_ = emptyProtobufList();
    }
    /**
     * <pre>
     * PSS signature with RSA public key. The public key is formatted as a
     * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
     * developer key proof, the first 128 bits of the SHA-256 hash of the
     * public key must equal the crx_id.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
     */
    private void removeSha256WithRsa(int index) {
      ensureSha256WithRsaIsMutable();
      sha256WithRsa_.remove(index);
    }

    public static final int SHA256_WITH_ECDSA_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<crx_file.Crx3.AsymmetricKeyProof> sha256WithEcdsa_;
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public java.util.List<crx_file.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public java.util.List<? extends crx_file.Crx3.AsymmetricKeyProofOrBuilder> 
        getSha256WithEcdsaOrBuilderList() {
      return sha256WithEcdsa_;
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public int getSha256WithEcdsaCount() {
      return sha256WithEcdsa_.size();
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    @java.lang.Override
    public crx_file.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
      return sha256WithEcdsa_.get(index);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    public crx_file.Crx3.AsymmetricKeyProofOrBuilder getSha256WithEcdsaOrBuilder(
        int index) {
      return sha256WithEcdsa_.get(index);
    }
    private void ensureSha256WithEcdsaIsMutable() {
      com.google.protobuf.Internal.ProtobufList<crx_file.Crx3.AsymmetricKeyProof> tmp = sha256WithEcdsa_;
      if (!tmp.isModifiable()) {
        sha256WithEcdsa_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }

    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void setSha256WithEcdsa(
        int index, crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.set(index, value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addSha256WithEcdsa(
        int index, crx_file.Crx3.AsymmetricKeyProof value) {
      value.getClass();
  ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.add(index, value);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void addAllSha256WithEcdsa(
        java.lang.Iterable<? extends crx_file.Crx3.AsymmetricKeyProof> values) {
      ensureSha256WithEcdsaIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, sha256WithEcdsa_);
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void clearSha256WithEcdsa() {
      sha256WithEcdsa_ = emptyProtobufList();
    }
    /**
     * <pre>
     * ECDSA signature, using the NIST P-256 curve. Public key appears in
     * named-curve format.
     * The pinned algorithm will be this, at least on 2017-01-01.
     * </pre>
     *
     * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
     */
    private void removeSha256WithEcdsa(int index) {
      ensureSha256WithEcdsaIsMutable();
      sha256WithEcdsa_.remove(index);
    }

    public static final int VERIFIED_CONTENTS_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString verifiedContents_;
    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     * @return Whether the verifiedContents field is set.
     */
    @java.lang.Override
    public boolean hasVerifiedContents() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     * @return The verifiedContents.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getVerifiedContents() {
      return verifiedContents_;
    }
    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     * @param value The verifiedContents to set.
     */
    private void setVerifiedContents(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      verifiedContents_ = value;
    }
    /**
     * <pre>
     * A verified contents file containing signatures over the archive contents.
     * The verified contents are encoded in UTF-8 and then GZIP-compressed.
     * Consult
     * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
     * for information about the verified contents format.
     * </pre>
     *
     * <code>optional bytes verified_contents = 4;</code>
     */
    private void clearVerifiedContents() {
      bitField0_ = (bitField0_ & ~0x00000001);
      verifiedContents_ = getDefaultInstance().getVerifiedContents();
    }

    public static final int SIGNED_HEADER_DATA_FIELD_NUMBER = 10000;
    private com.google.protobuf.ByteString signedHeaderData_;
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return Whether the signedHeaderData field is set.
     */
    @java.lang.Override
    public boolean hasSignedHeaderData() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @return The signedHeaderData.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignedHeaderData() {
      return signedHeaderData_;
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     * @param value The signedHeaderData to set.
     */
    private void setSignedHeaderData(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      signedHeaderData_ = value;
    }
    /**
     * <pre>
     * The binary form of a SignedData message. We do not use a nested
     * SignedData message, as handlers of this message must verify the proofs
     * on exactly these bytes, so it is convenient to parse in two steps.
     * All proofs in this CrxFile message are on the value
     * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
     * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
     * is encoded using UTF-8, signed_header_size is the size in octets of the
     * contents of this field and is encoded using 4 octets in little-endian
     * order, signed_header_data is exactly the content of this field, and
     * archive is the remaining contents of the file following the header.
     * </pre>
     *
     * <code>optional bytes signed_header_data = 10000;</code>
     */
    private void clearSignedHeaderData() {
      bitField0_ = (bitField0_ & ~0x00000002);
      signedHeaderData_ = getDefaultInstance().getSignedHeaderData();
    }

    public static crx_file.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.CrxFileHeader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.CrxFileHeader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.CrxFileHeader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(crx_file.Crx3.CrxFileHeader prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.CrxFileHeader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          crx_file.Crx3.CrxFileHeader, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.CrxFileHeader)
        crx_file.Crx3.CrxFileHeaderOrBuilder {
      // Construct using crx_file.Crx3.CrxFileHeader.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public java.util.List<crx_file.Crx3.AsymmetricKeyProof> getSha256WithRsaList() {
        return java.util.Collections.unmodifiableList(
            instance.getSha256WithRsaList());
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public int getSha256WithRsaCount() {
        return instance.getSha256WithRsaCount();
      }/**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      @java.lang.Override
      public crx_file.Crx3.AsymmetricKeyProof getSha256WithRsa(int index) {
        return instance.getSha256WithRsa(index);
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.setSha256WithRsa(index, value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder setSha256WithRsa(
          int index, crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.setSha256WithRsa(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithRsa(value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithRsa(index, value);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithRsa(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addSha256WithRsa(
          int index, crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithRsa(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder addAllSha256WithRsa(
          java.lang.Iterable<? extends crx_file.Crx3.AsymmetricKeyProof> values) {
        copyOnWrite();
        instance.addAllSha256WithRsa(values);
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder clearSha256WithRsa() {
        copyOnWrite();
        instance.clearSha256WithRsa();
        return this;
      }
      /**
       * <pre>
       * PSS signature with RSA public key. The public key is formatted as a
       * X.509 SubjectPublicKeyInfo block, as in CRX₂. In the common case of a
       * developer key proof, the first 128 bits of the SHA-256 hash of the
       * public key must equal the crx_id.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_rsa = 2;</code>
       */
      public Builder removeSha256WithRsa(int index) {
        copyOnWrite();
        instance.removeSha256WithRsa(index);
        return this;
      }

      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public java.util.List<crx_file.Crx3.AsymmetricKeyProof> getSha256WithEcdsaList() {
        return java.util.Collections.unmodifiableList(
            instance.getSha256WithEcdsaList());
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public int getSha256WithEcdsaCount() {
        return instance.getSha256WithEcdsaCount();
      }/**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      @java.lang.Override
      public crx_file.Crx3.AsymmetricKeyProof getSha256WithEcdsa(int index) {
        return instance.getSha256WithEcdsa(index);
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.setSha256WithEcdsa(index, value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder setSha256WithEcdsa(
          int index, crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.setSha256WithEcdsa(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithEcdsa(value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, crx_file.Crx3.AsymmetricKeyProof value) {
        copyOnWrite();
        instance.addSha256WithEcdsa(index, value);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithEcdsa(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addSha256WithEcdsa(
          int index, crx_file.Crx3.AsymmetricKeyProof.Builder builderForValue) {
        copyOnWrite();
        instance.addSha256WithEcdsa(index,
            builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder addAllSha256WithEcdsa(
          java.lang.Iterable<? extends crx_file.Crx3.AsymmetricKeyProof> values) {
        copyOnWrite();
        instance.addAllSha256WithEcdsa(values);
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder clearSha256WithEcdsa() {
        copyOnWrite();
        instance.clearSha256WithEcdsa();
        return this;
      }
      /**
       * <pre>
       * ECDSA signature, using the NIST P-256 curve. Public key appears in
       * named-curve format.
       * The pinned algorithm will be this, at least on 2017-01-01.
       * </pre>
       *
       * <code>repeated .crx_file.AsymmetricKeyProof sha256_with_ecdsa = 3;</code>
       */
      public Builder removeSha256WithEcdsa(int index) {
        copyOnWrite();
        instance.removeSha256WithEcdsa(index);
        return this;
      }

      /**
       * <pre>
       * A verified contents file containing signatures over the archive contents.
       * The verified contents are encoded in UTF-8 and then GZIP-compressed.
       * Consult
       * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
       * for information about the verified contents format.
       * </pre>
       *
       * <code>optional bytes verified_contents = 4;</code>
       * @return Whether the verifiedContents field is set.
       */
      @java.lang.Override
      public boolean hasVerifiedContents() {
        return instance.hasVerifiedContents();
      }
      /**
       * <pre>
       * A verified contents file containing signatures over the archive contents.
       * The verified contents are encoded in UTF-8 and then GZIP-compressed.
       * Consult
       * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
       * for information about the verified contents format.
       * </pre>
       *
       * <code>optional bytes verified_contents = 4;</code>
       * @return The verifiedContents.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getVerifiedContents() {
        return instance.getVerifiedContents();
      }
      /**
       * <pre>
       * A verified contents file containing signatures over the archive contents.
       * The verified contents are encoded in UTF-8 and then GZIP-compressed.
       * Consult
       * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
       * for information about the verified contents format.
       * </pre>
       *
       * <code>optional bytes verified_contents = 4;</code>
       * @param value The verifiedContents to set.
       * @return This builder for chaining.
       */
      public Builder setVerifiedContents(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setVerifiedContents(value);
        return this;
      }
      /**
       * <pre>
       * A verified contents file containing signatures over the archive contents.
       * The verified contents are encoded in UTF-8 and then GZIP-compressed.
       * Consult
       * https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/verified_contents.h
       * for information about the verified contents format.
       * </pre>
       *
       * <code>optional bytes verified_contents = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVerifiedContents() {
        copyOnWrite();
        instance.clearVerifiedContents();
        return this;
      }

      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return Whether the signedHeaderData field is set.
       */
      @java.lang.Override
      public boolean hasSignedHeaderData() {
        return instance.hasSignedHeaderData();
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return The signedHeaderData.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignedHeaderData() {
        return instance.getSignedHeaderData();
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @param value The signedHeaderData to set.
       * @return This builder for chaining.
       */
      public Builder setSignedHeaderData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignedHeaderData(value);
        return this;
      }
      /**
       * <pre>
       * The binary form of a SignedData message. We do not use a nested
       * SignedData message, as handlers of this message must verify the proofs
       * on exactly these bytes, so it is convenient to parse in two steps.
       * All proofs in this CrxFile message are on the value
       * "CRX3 SignedData&#92;x00" + signed_header_size + signed_header_data +
       * archive, where "&#92;x00" indicates an octet with value 0, "CRX3 SignedData"
       * is encoded using UTF-8, signed_header_size is the size in octets of the
       * contents of this field and is encoded using 4 octets in little-endian
       * order, signed_header_data is exactly the content of this field, and
       * archive is the remaining contents of the file following the header.
       * </pre>
       *
       * <code>optional bytes signed_header_data = 10000;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignedHeaderData() {
        copyOnWrite();
        instance.clearSignedHeaderData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.CrxFileHeader)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new crx_file.Crx3.CrxFileHeader();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "sha256WithRsa_",
              crx_file.Crx3.AsymmetricKeyProof.class,
              "sha256WithEcdsa_",
              crx_file.Crx3.AsymmetricKeyProof.class,
              "verifiedContents_",
              "signedHeaderData_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0002\u2710\u0004\u0000\u0002\u0000\u0002\u001b\u0003\u001b" +
                "\u0004\u100a\u0000\u2710\u100a\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<crx_file.Crx3.CrxFileHeader> parser = PARSER;
          if (parser == null) {
            synchronized (crx_file.Crx3.CrxFileHeader.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<crx_file.Crx3.CrxFileHeader>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.CrxFileHeader)
    private static final crx_file.Crx3.CrxFileHeader DEFAULT_INSTANCE;
    static {
      CrxFileHeader defaultInstance = new CrxFileHeader();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        CrxFileHeader.class, defaultInstance);
    }

    public static crx_file.Crx3.CrxFileHeader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<CrxFileHeader> PARSER;

    public static com.google.protobuf.Parser<CrxFileHeader> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface AsymmetricKeyProofOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.AsymmetricKeyProof)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional bytes public_key = 1;</code>
     * @return Whether the publicKey field is set.
     */
    boolean hasPublicKey();
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return The publicKey.
     */
    com.google.protobuf.ByteString getPublicKey();

    /**
     * <code>optional bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <code>optional bytes signature = 2;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code crx_file.AsymmetricKeyProof}
   */
  public  static final class AsymmetricKeyProof extends
      com.google.protobuf.GeneratedMessageLite<
          AsymmetricKeyProof, AsymmetricKeyProof.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.AsymmetricKeyProof)
      AsymmetricKeyProofOrBuilder {
    private AsymmetricKeyProof() {
      publicKey_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString publicKey_;
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return Whether the publicKey field is set.
     */
    @java.lang.Override
    public boolean hasPublicKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     * @return The publicKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     * @param value The publicKey to set.
     */
    private void setPublicKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      publicKey_ = value;
    }
    /**
     * <code>optional bytes public_key = 1;</code>
     */
    private void clearPublicKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      publicKey_ = getDefaultInstance().getPublicKey();
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>optional bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bytes signature = 2;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <code>optional bytes signature = 2;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      signature_ = value;
    }
    /**
     * <code>optional bytes signature = 2;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000002);
      signature_ = getDefaultInstance().getSignature();
    }

    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.AsymmetricKeyProof parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(crx_file.Crx3.AsymmetricKeyProof prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.AsymmetricKeyProof}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          crx_file.Crx3.AsymmetricKeyProof, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.AsymmetricKeyProof)
        crx_file.Crx3.AsymmetricKeyProofOrBuilder {
      // Construct using crx_file.Crx3.AsymmetricKeyProof.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional bytes public_key = 1;</code>
       * @return Whether the publicKey field is set.
       */
      @java.lang.Override
      public boolean hasPublicKey() {
        return instance.hasPublicKey();
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @return The publicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKey() {
        return instance.getPublicKey();
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @param value The publicKey to set.
       * @return This builder for chaining.
       */
      public Builder setPublicKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPublicKey(value);
        return this;
      }
      /**
       * <code>optional bytes public_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicKey() {
        copyOnWrite();
        instance.clearPublicKey();
        return this;
      }

      /**
       * <code>optional bytes signature = 2;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <code>optional bytes signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.AsymmetricKeyProof)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new crx_file.Crx3.AsymmetricKeyProof();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "publicKey_",
              "signature_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0000\u0001\u100a\u0000\u0002" +
                "\u100a\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<crx_file.Crx3.AsymmetricKeyProof> parser = PARSER;
          if (parser == null) {
            synchronized (crx_file.Crx3.AsymmetricKeyProof.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<crx_file.Crx3.AsymmetricKeyProof>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.AsymmetricKeyProof)
    private static final crx_file.Crx3.AsymmetricKeyProof DEFAULT_INSTANCE;
    static {
      AsymmetricKeyProof defaultInstance = new AsymmetricKeyProof();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        AsymmetricKeyProof.class, defaultInstance);
    }

    public static crx_file.Crx3.AsymmetricKeyProof getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<AsymmetricKeyProof> PARSER;

    public static com.google.protobuf.Parser<AsymmetricKeyProof> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SignedDataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:crx_file.SignedData)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return Whether the crxId field is set.
     */
    boolean hasCrxId();
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return The crxId.
     */
    com.google.protobuf.ByteString getCrxId();
  }
  /**
   * Protobuf type {@code crx_file.SignedData}
   */
  public  static final class SignedData extends
      com.google.protobuf.GeneratedMessageLite<
          SignedData, SignedData.Builder> implements
      // @@protoc_insertion_point(message_implements:crx_file.SignedData)
      SignedDataOrBuilder {
    private SignedData() {
      crxId_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int CRX_ID_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString crxId_;
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return Whether the crxId field is set.
     */
    @java.lang.Override
    public boolean hasCrxId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @return The crxId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCrxId() {
      return crxId_;
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     * @param value The crxId to set.
     */
    private void setCrxId(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      crxId_ = value;
    }
    /**
     * <pre>
     * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
     * 16 bytes long.
     * </pre>
     *
     * <code>optional bytes crx_id = 1;</code>
     */
    private void clearCrxId() {
      bitField0_ = (bitField0_ & ~0x00000001);
      crxId_ = getDefaultInstance().getCrxId();
    }

    public static crx_file.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.SignedData parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static crx_file.Crx3.SignedData parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.SignedData parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.SignedData parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static crx_file.Crx3.SignedData parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(crx_file.Crx3.SignedData prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code crx_file.SignedData}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          crx_file.Crx3.SignedData, Builder> implements
        // @@protoc_insertion_point(builder_implements:crx_file.SignedData)
        crx_file.Crx3.SignedDataOrBuilder {
      // Construct using crx_file.Crx3.SignedData.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return Whether the crxId field is set.
       */
      @java.lang.Override
      public boolean hasCrxId() {
        return instance.hasCrxId();
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return The crxId.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCrxId() {
        return instance.getCrxId();
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @param value The crxId to set.
       * @return This builder for chaining.
       */
      public Builder setCrxId(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCrxId(value);
        return this;
      }
      /**
       * <pre>
       * This is simple binary, not UTF-8 encoded mpdecimal; i.e. it is exactly
       * 16 bytes long.
       * </pre>
       *
       * <code>optional bytes crx_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCrxId() {
        copyOnWrite();
        instance.clearCrxId();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:crx_file.SignedData)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new crx_file.Crx3.SignedData();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "crxId_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u100a\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<crx_file.Crx3.SignedData> parser = PARSER;
          if (parser == null) {
            synchronized (crx_file.Crx3.SignedData.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<crx_file.Crx3.SignedData>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:crx_file.SignedData)
    private static final crx_file.Crx3.SignedData DEFAULT_INSTANCE;
    static {
      SignedData defaultInstance = new SignedData();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SignedData.class, defaultInstance);
    }

    public static crx_file.Crx3.SignedData getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SignedData> PARSER;

    public static com.google.protobuf.Parser<SignedData> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
